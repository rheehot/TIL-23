# 퀵정렬

목표 : 한 배열을 오름차순 (또는 내림차순) 으로 정렬.

퀵정렬은 역사적으로 가장 유명한 알고리즘 중 하나입니다. 퀵정렬은 '재귀' 개념이 불투명하던 시기인 1959년, Tony Hoare에 의해 발명됐습니다.

아래는 이해하기 쉽도록 Java로 구현한 코드입니다 :

```java
public void main(String[] args){
  public int quicksort(int a){
    
  }
}
```

아래 코드를 main 메소드에서 테스트 합니다 :

```java
int[] list = {10, 0, 3, 9, 2, 14, 8, 27, 1, 5, 8, -1, 26};
quicksort(input);
```

다음은 작동 방식입니다. 배열이 주어지면, quicksort()는 "pivot" 변수에 따라 배열은 세 부분으로 나눕니다. 여기서, 배열의 가운데 요소를 pivot으로 사용합니다. ( 피벗을 선택하는 다른 방법은 나중에 살펴보겠습니다. )

pivot보다 작은 모든 원소들은 새로운 배열 `less`로 이동시킵니다. pivot과 같은 모든 원소들은 `equal`배열에 넣습니다. 눈치 채셨겠지만, pivot 보다 큰 원소들은 세번째 배열 `greater`에 넣습니다.  참고로 Java는 연산자 오버로딩을 지원하지 않습니다. 객체를 정렬하는 방법은 나중에 살펴보겠습니다. 

일단 세가지 배열을 구하고 나면, quicksort()는 재귀적으로 `less`배열과 `greater`배열을 정렬합니다. 그리고나서, 정렬된 두 하위 배열(sub-array)을 `equal`배열과 붙여 최종결과를 얻어냅니다.

# 예제

예제를 살펴 보겠습니다. 배열은 다음과 같이 초기화 하였습니다.

```java
{10, 0, 3, 9, 2, 14, 8, 27, 1, 5, 8, -1, 26}
```

먼저, 8을 pivot을 선택합니다. 배열의 중간에 있는 값이 8이기 때문입니다. 다음에는 배열은 less, equal, greater 로 나누겠습니다.

```java
less    : {0, 3, 2, 1, 5, -1}
equal   : {8, 8}
greater : {10, 9, 14, 27, 26}
```

`less`와 `greater`이 동일한 수의 원소를 갖고 있으므로, 잘 나누어졌습니다. 또한 배열을 반으로 가르는 좋은 pivot을 골랐습니다.

`less`와 `greater`는 아직 정렬되지 않았습니다. 그래서 quicksort()를 다시 호출하여 두 하위배열(subarray)을 정렬하겠습니다. 이번에 호출된 quicksort()도 앞에서 한 것과 똑같은 일을 합니다 : pivot을 고르고 하위 배열을 다시 세 개의 더 작은 배열로 나눕니다.

`less` 배열로 이 과정을 살펴보겠습니다:

```java
{0, 3, 2, 1, 5, -1}
```

여기서 pivot은 중간에 있는 값 중 `1`로 선택하겠습니다( `2`로 해도 상관없습니다. )  다시 pivot 주변에서 3개의 하위배열을 만들어냅니다 :

```java
less    : {0, -1}
equal   : {1}
greater : {3, 2, 5}
```

아직 끝나지 않았습니다. 재귀적으로 `less`와 `greater` 배열에서 quicksort()가 다시 호출됩니다.  `less`를 다시 살펴보겠습니다 :

```java
{0, -1}
```

pivot으로 `-1`을 선택하겠습니다. 이제 하위 배열(subarrray)은 아래와 같습니다.

```java
less    : {}
equal   : {-1}
greater : {0}
```

`-1`보다 작은 값이 없기 때문에 `less`배열은 비었습니다. 다른 배열들은 값이 하나씩 들어있습니다. 재귀는 이 수준에서 종료합니다. 이제 남아있는 `greater`배열을 정렬하기 위해 다시 되돌아갑니다.

`greater`배열 입니다 :

```java
{3, 2, 5}
```

이번에 할 것도 전에 했던것과 똑같습니다 : 가운데 원소인 `2`를 pivot으로 선택하고 하위배열을 채워나갑니다 :

```java
less    : {}
equal   : {2}
greater : {3, 5}
```

여기서 사실 pivot으로 `3`을 선택하는 것이 더 낫습니다. -- 이렇게 하면 이미 끝났습니다.  그러나 지금은 `greater`배열이 확실히 정렬됐는지 확인하기 위해 재귀를 한번 더 돌아야합니다. 이것이 바로 pivot을 잘 선택하는 것이 중요한 이유입니다. pivot을 계속 잘못 선택하면, quicksort는 그만큼 느려집니다. ( 많이 느려집니다. )

우리가 분할시켜 찾은 `greater`의 하위배열입니다 :

```java
less    : {3}
equal   : {5}
greater : {}
```

